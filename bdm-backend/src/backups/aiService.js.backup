const axios = require('axios');
const OpenAI = require('openai');
require('dotenv').config();

// Determine which AI service to use
const USE_OPENROUTER = process.env.USE_OPENROUTER === 'true';
const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const AI_MODEL = process.env.AI_MODEL || 'meta-llama/llama-3.1-8b-instruct';

// Fallback models (priority order)
const FALLBACK_MODELS = process.env.AI_FALLBACK_MODELS
  ? process.env.AI_FALLBACK_MODELS.split(',')
  : [
      'google/gemini-flash-1.5',
      'mistralai/mistral-7b-instruct',
      'microsoft/phi-3-mini-128k-instruct'
    ];

// Initialize OpenAI client (fallback)
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY
});

class AIService {

  // Generic AI request handler with automatic fallback
  async makeAIRequest(messages, temperature = 0.7) {
    if (USE_OPENROUTER && OPENROUTER_API_KEY) {
      return await this.callOpenRouterWithFallback(messages, temperature);
    } else if (OPENAI_API_KEY) {
      return await this.callOpenAI(messages, temperature);
    } else {
      throw new Error('No AI API key configured. Please set OPENROUTER_API_KEY or OPENAI_API_KEY in .env');
    }
  }

  // OpenRouter with automatic model fallback
  async callOpenRouterWithFallback(messages, temperature) {
    // Build list of models to try (primary + fallbacks)
    const modelsToTry = [AI_MODEL, ...FALLBACK_MODELS];
    
    let lastError = null;
    
    // Try each model in sequence
    for (let i = 0; i < modelsToTry.length; i++) {
      const model = modelsToTry[i];
      
      try {
        console.log(`ü§ñ Attempting with model ${i + 1}/${modelsToTry.length}: ${model}`);
        
        const result = await this.callOpenRouter(messages, temperature, model);
        
        console.log(`‚úÖ Success with model: ${model}`);
        return result;
        
      } catch (error) {
        lastError = error;
        const errorMsg = error.message || JSON.stringify(error);
        
        // Check if it's a rate limit error
        if (errorMsg.includes('rate-limited') || errorMsg.includes('429')) {
          console.log(`‚ö†Ô∏è Rate limited on ${model}, trying next model...`);
          continue;
        }
        
        // Check if model not found
        if (errorMsg.includes('404') || errorMsg.includes('not found')) {
          console.log(`‚ö†Ô∏è Model ${model} not available, trying next...`);
          continue;
        }
        
        // For other errors, also try next model
        console.log(`‚ö†Ô∏è Error with ${model}: ${errorMsg.substring(0, 100)}...`);
        console.log(`   Trying next model...`);
        continue;
      }
    }
    
    // If all models failed, try OpenAI as last resort
    if (OPENAI_API_KEY && !USE_OPENROUTER) {
      console.log('‚ö†Ô∏è All OpenRouter models failed, falling back to OpenAI...');
      try {
        return await this.callOpenAI(messages, temperature);
      } catch (openaiError) {
        console.error('‚ùå OpenAI fallback also failed');
      }
    }
    
    // All models failed
    throw new Error(`All AI models failed. Last error: ${lastError?.message || lastError}`);
  }

  // OpenRouter API call (updated to accept model parameter)
  async callOpenRouter(messages, temperature, model = null) {
    try {
      const modelToUse = model || AI_MODEL;
      
      const requestBody = {
        model: modelToUse,
        messages: messages,
        temperature: temperature
      };
      
      // Only add response_format for models that support it
      // Some free models don't support JSON mode
      if (modelToUse.includes('gpt') || modelToUse.includes('claude')) {
        requestBody.response_format = { type: "json_object" };
      }
      
      const response = await axios.post(
        'https://openrouter.ai/api/v1/chat/completions',
        requestBody,
        {
          headers: {
            'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': 'http://localhost:5000',
            'X-Title': 'BDM System'
          },
          timeout: 30000 // 30 second timeout
        }
      );

      return {
        content: response.data.choices[0].message.content,
        tokensUsed: response.data.usage?.total_tokens || 0,
        model: modelToUse
      };

    } catch (error) {
      // Throw detailed error for fallback handling
      if (error.response?.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  // OpenAI API call (fallback)
  async callOpenAI(messages, temperature) {
    try {
      console.log('ü§ñ Using OpenAI (fallback)');
      
      const completion = await openai.chat.completions.create({
        model: process.env.OPENAI_MODEL || 'gpt-3.5-turbo',
        messages: messages,
        temperature: temperature,
        response_format: { type: "json_object" }
      });

      return {
        content: completion.choices[0].message.content,
        tokensUsed: completion.usage.total_tokens,
        model: process.env.OPENAI_MODEL
      };

    } catch (error) {
      console.error('OpenAI API Error:', error.message);
      throw new Error(`OpenAI API failed: ${error.message}`);
    }
  }
  
  // Generate all clauses for a document type
  async generateClauses(documentType, context = {}) {
    try {
      const prompt = this.buildClauseGenerationPrompt(documentType, context);
      
      const messages = [
        {
          role: 'system',
          content: 'You are a professional document generator. Generate structured, professional document clauses in JSON format. CRITICAL: Always return ONLY valid JSON, nothing else. No markdown, no code blocks, just pure JSON.'
        },
        {
          role: 'user',
          content: prompt
        }
      ];

      const result = await this.makeAIRequest(messages, 0.7);
      
      // Clean the response (remove markdown code blocks if present)
      let cleanedContent = result.content.trim();
      
      // Remove markdown code blocks
      if (cleanedContent.startsWith('```json')) {
        cleanedContent = cleanedContent.replace(/```json\n?/g, '').replace(/```\n?$/g, '');
      } else if (cleanedContent.startsWith('```')) {
        cleanedContent = cleanedContent.replace(/```\n?/g, '').replace(/```\n?$/g, '');
      }
      
      // Try to parse JSON
      let response;
      try {
        response = JSON.parse(cleanedContent);
      } catch (parseError) {
        console.error('‚ùå JSON Parse Error. Raw response:', cleanedContent.substring(0, 500));
        throw new Error(`Invalid JSON response from AI: ${parseError.message}`);
      }
      
      // Validate response structure
      if (!response.clauses || !Array.isArray(response.clauses)) {
        console.error('‚ùå Invalid response structure:', response);
        throw new Error('AI response missing "clauses" array');
      }
      
      // Validate each clause has required fields
      for (const clause of response.clauses) {
        if (!clause.clause_type || !clause.content || !clause.category) {
          console.error('‚ùå Invalid clause structure:', clause);
          throw new Error('Clause missing required fields (clause_type, content, or category)');
        }
      }
      
      return {
        success: true,
        clauses: response.clauses,
        tokensUsed: result.tokensUsed,
        model: result.model
      };

    } catch (error) {
      console.error('AI Generation Error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Build prompt for clause generation
  buildClauseGenerationPrompt(documentType, context) {
    const contextStr = Object.keys(context).length > 0
      ? `\n\nContext Information:\n${JSON.stringify(context, null, 2)}`
      : '';

    // Get clause suggestions based on document type
    const clauseSuggestions = this.getClauseSuggestionsForDocumentType(documentType);

    return `Generate all necessary clauses for a ${documentType} document.${contextStr}

CRITICAL INSTRUCTIONS:
1. Return ONLY valid JSON
2. No markdown, no code blocks, no explanations
3. Just the raw JSON object
4. Follow the exact structure shown below

Return this EXACT JSON structure:
{
  "clauses": [
    {
      "clause_type": "header",
      "content": "The actual clause content here",
      "category": "${documentType}"
    }
  ]
}

${clauseSuggestions}

Rules:
- Use placeholders like [Company Name], [Candidate Name], [Position], [Salary]
- Make content professional and legally appropriate
- Generate AS MANY OR AS FEW clauses as needed for this document type
- Each clause should be complete and well-written
- DO NOT include any text outside the JSON object
- DO NOT wrap JSON in markdown code blocks`;
  }

  // Get clause suggestions based on document type
  getClauseSuggestionsForDocumentType(documentType) {
    const suggestions = {
      offer_letter: `
Suggested clauses (generate all that apply):
1. header - Company letterhead with [Company Name], [Company Address]
2. greeting - "Dear [Candidate Name],"
3. opening - Introduction about the offer
4. position_details - Position: [Position], Department: [Department], Reporting To: [Manager]
5. compensation - Salary: [Salary], Benefits: [Benefits]
6. responsibilities - Key job duties (use bullet points with *)
7. start_date - When employment begins
8. probation_period - If applicable
9. terms - Terms and conditions
10. closing - Professional closing
11. signature - [Sender Name], [Sender Title]`,

      nda: `
Suggested clauses (generate all that apply):
1. header - Agreement title and date
2. parties - The parties entering the agreement
3. recitals - Background and purpose
4. definitions - Key terms defined
5. confidential_information - What is considered confidential
6. obligations - What parties must do
7. exclusions - What is NOT confidential
8. term - How long agreement lasts
9. return_of_materials - Upon termination
10. remedies - What happens if breached
11. miscellaneous - General provisions
12. signature - Signature blocks`,

      employment_contract: `
Suggested clauses (generate all that apply):
1. header - Contract title
2. parties - Employer and employee
3. recitals - Background
4. position - Job title and duties
5. term - Employment period
6. compensation - Salary and bonuses
7. benefits - Health, retirement, etc.
8. hours - Working hours and location
9. probation - Probationary period
10. termination - How employment can end
11. severance - Severance provisions
12. confidentiality - Confidentiality obligations
13. intellectual_property - IP ownership
14. non_compete - Non-compete clause
15. dispute_resolution - How disputes handled
16. amendments - How to modify agreement
17. governing_law - Which laws apply
18. signature - Signature blocks`,

      invoice: `
Suggested clauses (generate all that apply):
1. header - Company info and invoice #
2. invoice_details - Date, due date, PO number
3. bill_to - Customer information
4. ship_to - Shipping address (if different)
5. items_table - Line items with descriptions, qty, price
6. subtotal - Subtotal calculation
7. tax - Tax amount
8. total - Grand total
9. payment_terms - Payment instructions
10. notes - Additional notes or terms
11. footer - Thank you message`,

      default: `
Generate all clauses appropriate for a ${documentType} document.
Typical structure might include:
1. header - Document title and identifying info
2. opening - Introduction or purpose
3. body_clauses - Main content (as many as needed)
4. terms - Terms and conditions
5. closing - Conclusion
6. signature - Signature blocks

Add or remove clauses as appropriate for this document type.`
    };

    return suggestions[documentType] || suggestions.default;
  }

  // Generate template structure with AI suggestions
  async generateTemplateStructure(documentType, description = '', availableClauses = []) {
    try {
      const clausesList = availableClauses.length > 0
        ? `\n\nAvailable clauses to choose from:\n${JSON.stringify(availableClauses.map(c => ({
            id: c.id,
            clause_type: c.clause_type,
            preview: c.content.substring(0, 100) + '...'
          })), null, 2)}`
        : '';

      const prompt = `Create an optimal template structure for a ${documentType} document.
Description: ${description}${clausesList}

Analyze the document type and suggest:
1. Which clause types should be included
2. The optimal order of clauses
3. Any missing clauses that should be created

${availableClauses.length > 0 ? 'Select from the available clauses provided above by their IDs.' : 'Suggest clause types that should be created.'}

Return JSON with this EXACT structure:
{
  "template_name": "Professional name for the template",
  "document_type": "${documentType}",
  "description": "Brief description of the template purpose",
  "recommended_clause_ids": [1, 3, 5, 7],
  "clause_order_explanation": "Brief explanation of why this order",
  "missing_clauses": [
    {
      "clause_type": "probation_period",
      "reason": "Important for employment contracts"
    }
  ]
}

IMPORTANT: Return ONLY valid JSON, no other text`;

      const messages = [
        {
          role: 'system',
          content: 'You are a document structure expert. Analyze documents and suggest optimal clause arrangements. Always return valid JSON.'
        },
        {
          role: 'user',
          content: prompt
        }
      ];

      const result = await this.makeAIRequest(messages, 0.6);

      return {
        success: true,
        template: JSON.parse(result.content),
        tokensUsed: result.tokensUsed,
        model: result.model
      };

    } catch (error) {
      console.error('Template Generation Error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Fill template with actual data
  async fillTemplate(clauses, data) {
    try {
      const prompt = `Fill this document template with the provided data:

Template Clauses: ${JSON.stringify(clauses, null, 2)}

Data to fill: ${JSON.stringify(data, null, 2)}

Replace all placeholders like [Company Name], [Candidate Name], [Position], [Salary] etc. with actual values from the data.

CRITICAL INSTRUCTIONS:
1. Return ONLY valid JSON
2. No markdown, no code blocks, no explanations
3. Just the raw JSON object

Return this EXACT JSON structure:
{
  "filled_clauses": [
    {
      "clause_type": "header",
      "content": "Filled content with actual data"
    }
  ]
}

DO NOT wrap JSON in markdown code blocks.`;

      const messages = [
        {
          role: 'system',
          content: 'You are a document filling assistant. Replace placeholders with actual data. Return ONLY valid JSON, no markdown.'
        },
        {
          role: 'user',
          content: prompt
        }
      ];

      const result = await this.makeAIRequest(messages, 0.3);

      // Clean the response (remove markdown code blocks if present)
      let cleanedContent = result.content.trim();
      
      // Remove markdown code blocks
      if (cleanedContent.startsWith('```json')) {
        cleanedContent = cleanedContent.replace(/```json\n?/g, '').replace(/```\n?$/g, '');
      } else if (cleanedContent.startsWith('```')) {
        cleanedContent = cleanedContent.replace(/```\n?/g, '').replace(/```\n?$/g, '');
      }
      
      // Try to parse JSON
      let response;
      try {
        response = JSON.parse(cleanedContent);
      } catch (parseError) {
        console.error('‚ùå JSON Parse Error in fillTemplate. Raw response:', cleanedContent.substring(0, 500));
        throw new Error(`Invalid JSON response from AI: ${parseError.message}`);
      }

      return {
        success: true,
        filledDocument: response,
        tokensUsed: result.tokensUsed,
        model: result.model
      };

    } catch (error) {
      console.error('Template Fill Error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // bdm-backend/src/services/aiService.js

  // NEW: Generate a single clause
  async generateSingleClause(clauseType, category, context = {}) {
    try {
      const contextStr = Object.keys(context).length > 0
        ? `\n\nContext Information:\n${JSON.stringify(context, null, 2)}`
        : '';

      const prompt = `Generate a single, complete document clause.

Document Category: ${category}
Clause Type: ${clauseType}
${contextStr}

CRITICAL INSTRUCTIONS:
1. Return ONLY valid JSON
2. No markdown, no code blocks, no explanations
3. Just the raw JSON object
4. The content should be professional and legally appropriate.
5. Use placeholders like [Company Name], [Employee Name] if no context is given.

Return this EXACT JSON structure:
{
  "clause": {
    "clause_type": "${clauseType}",
    "content": "The full, professional content of the clause goes here..."
  }
}

DO NOT wrap JSON in markdown code blocks.`;

      const messages = [
        {
          role: 'system',
          content: 'You are a professional legal document generator. You will generate a single, high-quality clause based on the user request. You ONLY return valid JSON.'
        },
        {
          role: 'user',
          content: prompt
        }
      ];

      const result = await this.makeAIRequest(messages, 0.7);

      // Clean the response
      let cleanedContent = result.content.trim();
      if (cleanedContent.startsWith('```json')) {
        cleanedContent = cleanedContent.replace(/```json\n?/g, '').replace(/```\n?$/g, '');
      } else if (cleanedContent.startsWith('```')) {
        cleanedContent = cleanedContent.replace(/```\n?/g, '').replace(/```\n?$/g, '');
      }

      // Try to parse JSON
      let response;
      try {
        response = JSON.parse(cleanedContent);
      } catch (parseError) {
        console.error('‚ùå JSON Parse Error in generateSingleClause. Raw:', cleanedContent.substring(0, 500));
        throw new Error(`Invalid JSON response from AI: ${parseError.message}`);
      }

      // Validate response
      if (!response.clause || !response.clause.clause_type || !response.clause.content) {
        console.error('‚ùå Invalid single clause structure:', response);
        throw new Error('AI response missing "clause" object with "clause_type" and "content"');
      }
      
      return {
        success: true,
        clause: response.clause,
        tokensUsed: result.tokensUsed,
        model: result.model
      };

    } catch (error) {
      console.error('AI Single Clause Generation Error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Get current AI configuration
  getAIConfig() {
    return {
      provider: USE_OPENROUTER ? 'OpenRouter' : 'OpenAI',
      model: USE_OPENROUTER ? AI_MODEL : (process.env.OPENAI_MODEL || 'gpt-3.5-turbo'),
      is_free: AI_MODEL.includes(':free'),
      api_configured: USE_OPENROUTER ? !!OPENROUTER_API_KEY : !!OPENAI_API_KEY
    };
  }
}

module.exports = new AIService();

